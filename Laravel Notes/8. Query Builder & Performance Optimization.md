# **8. Query Builder & Performance Optimization**  

## **1. Introduction to Query Builder**  
Laravel Query Builder provides a fluent interface to interact with the database using SQL-like queries without writing raw SQL. It is an alternative to Eloquent ORM and is useful for performance optimization in large-scale applications.  

### **Basic Query Builder Usage**  
```php
use Illuminate\Support\Facades\DB;

// Fetch all records from the 'users' table
$users = DB::table('users')->get();
```

---

## **2. Selecting Data**  
### **Fetching All Records**
```php
$users = DB::table('users')->get();
```
### **Fetching a Single Record**
```php
$user = DB::table('users')->where('email', 'john@example.com')->first();
```
### **Fetching a Specific Column**
```php
$names = DB::table('users')->pluck('name');
```
### **Using Select Clause**
```php
$users = DB::table('users')->select('name', 'email')->get();
```

---

## **3. Filtering Data**  
### **Using Where Clause**
```php
$users = DB::table('users')->where('status', 'active')->get();
```
### **Multiple Conditions**
```php
$users = DB::table('users')->where('status', 'active')->where('age', '>', 25)->get();
```
### **Using OR Condition**
```php
$users = DB::table('users')->where('status', 'active')->orWhere('role', 'admin')->get();
```
### **Using Between**
```php
$users = DB::table('users')->whereBetween('age', [20, 30])->get();
```
### **Using Like**
```php
$users = DB::table('users')->where('name', 'like', 'J%')->get();
```

---

## **4. Sorting & Pagination**  
### **Sorting Results**
```php
$users = DB::table('users')->orderBy('name', 'asc')->get();
```
### **Limiting Results**
```php
$users = DB::table('users')->limit(10)->get();
```
### **Pagination**
```php
$users = DB::table('users')->paginate(15);
```

---

## **5. Inserting Data**  
### **Basic Insert**
```php
DB::table('users')->insert([
    'name' => 'John Doe',
    'email' => 'john@example.com',
    'password' => bcrypt('password')
]);
```
### **Insert and Get ID**
```php
$id = DB::table('users')->insertGetId([
    'name' => 'Jane Doe',
    'email' => 'jane@example.com',
    'password' => bcrypt('password')
]);
```

---

## **6. Updating Data**  
```php
DB::table('users')->where('id', 1)->update(['status' => 'inactive']);
```

---

## **7. Deleting Data**  
```php
DB::table('users')->where('id', 1)->delete();
```

---

## **8. Performance Optimization**  

### **1. Use Indexing in Database**  
Ensure frequently queried columns (like `email` or `user_id`) have proper indexing.  
```sql
CREATE INDEX idx_email ON users(email);
```

### **2. Use Select Instead of Fetching All Columns**  
```php
$users = DB::table('users')->select('id', 'name')->get();
```
Fetching only necessary columns reduces memory usage.

### **3. Use Chunking for Large Queries**  
Instead of fetching all records at once, process them in chunks.  
```php
DB::table('users')->orderBy('id')->chunk(100, function ($users) {
    foreach ($users as $user) {
        // Process user
    }
});
```

### **4. Use Caching**  
```php
$users = Cache::remember('users', 600, function () {
    return DB::table('users')->get();
});
```
This stores the data in cache for 10 minutes.

### **5. Use Joins Instead of Multiple Queries**  
Instead of:  
```php
$orders = DB::table('orders')->where('user_id', 1)->get();
foreach ($orders as $order) {
    $user = DB::table('users')->where('id', $order->user_id)->first();
}
```
Use Join:
```php
$orders = DB::table('orders')
    ->join('users', 'users.id', '=', 'orders.user_id')
    ->select('orders.*', 'users.name as user_name')
    ->get();
```

### **6. Use Eager Loading in Eloquent**  
```php
$users = User::with('orders')->get();
```
Instead of running separate queries, this loads related data in a single query.

### **7. Avoid N+1 Query Problem**  
Using Lazy Loading:
```php
$users = User::all();
foreach ($users as $user) {
    echo $user->orders; // Triggers separate query for each user
}
```
Using Eager Loading:
```php
$users = User::with('orders')->get();
```
This improves performance by reducing database calls.

---

## **9. Raw Queries & Transactions**  

### **Executing Raw SQL**
```php
$users = DB::select('SELECT * FROM users WHERE status = ?', ['active']);
```

### **Using Transactions**
```php
DB::transaction(function () {
    DB::table('users')->where('id', 1)->update(['status' => 'active']);
    DB::table('orders')->where('user_id', 1)->update(['status' => 'processed']);
});
```
Ensures both queries run together; if one fails, both rollback.

---

## **10. Key Interview Questions on Query Builder & Performance Optimization**  

1. What is the difference between **Query Builder** and **Eloquent ORM**?  
2. When should you use **Query Builder over Eloquent**?  
3. How do you **optimize database queries** in Laravel?  
4. What is **chunking**, and why is it useful?  
5. How do you use **caching** to improve query performance?  
6. What is the **N+1 problem**, and how do you prevent it?  
7. How do you execute **raw SQL queries** in Laravel?  
8. What are **transactions**, and when should you use them?  
9. How do **Joins** improve performance compared to multiple queries?  
10. What is the difference between **lazy loading** and **eager loading** in Eloquent?  

---

### **1. What is the difference between Query Builder and Eloquent ORM?**  
**Query Builder**:  
- Provides a **fluent interface** for building and executing database queries.  
- Uses methods like `select()`, `where()`, and `join()` to generate SQL.  
- Does **not require models**; you work directly with tables.  
- Faster than Eloquent for complex queries since it avoids unnecessary model instantiation.  

**Eloquent ORM**:  
- An **Active Record** implementation that allows interaction with the database using **models**.  
- Provides relationships, events, and mutators to simplify data handling.  
- Slower than Query Builder but more readable and **object-oriented**.  

**When to use what?**  
- **Use Eloquent** when working with models and relationships.  
- **Use Query Builder** when optimizing performance for complex queries.  

---

### **2. When should you use Query Builder over Eloquent?**  
- When performance is critical (e.g., **complex joins, aggregations, bulk updates**).  
- When you need **raw SQL flexibility** (e.g., custom indexes, stored procedures).  
- When working with **large datasets** to avoid high memory usage from models.  

---

### **3. How do you optimize database queries in Laravel?**  
✅ **Use Eager Loading (`with()`)** to prevent the N+1 problem.  
✅ **Use indexes** on frequently queried columns.  
✅ **Use caching (`Cache::remember()`)** for repeated queries.  
✅ **Use `select()`** instead of `*` to fetch only necessary columns.  
✅ **Use `lazy()` or `chunk()`** when processing large datasets.  
✅ **Use Database Transactions** for multiple dependent operations.  
✅ **Use `EXPLAIN` SQL statement** to analyze and optimize queries.  

---

### **4. What is chunking, and why is it useful?**  
**Chunking** processes large datasets in **smaller chunks** to reduce memory usage.  

**Example**:  
```php
User::chunk(100, function ($users) {
    foreach ($users as $user) {
        // Process user data
    }
});
```
📌 **Why use it?**  
- Prevents memory overload for large datasets.  
- Reduces execution time for batch operations.  

---

### **5. How do you use caching to improve query performance?**  
Use Laravel’s **cache system** (`Cache` facade) to store query results and reduce database load.  

**Example using `Cache::remember()`**:  
```php
$users = Cache::remember('users_list', 60, function () {
    return User::all();
});
```
📌 **Why?**  
- Speeds up query performance.  
- Reduces unnecessary database hits.  

---

### **6. What is the N+1 problem, and how do you prevent it?**  
🔴 **The N+1 Problem** occurs when Laravel makes multiple queries instead of one optimized query.  

**Example (bad practice)**:  
```php
$users = User::all();
foreach ($users as $user) {
    echo $user->profile->bio; // Queries `profile` for each user
}
```
👉 **Solution: Use Eager Loading (`with()`)**  
```php
$users = User::with('profile')->get(); // Fetches users & profiles in 1 query
```
✅ **Reduces queries from N+1 to just 1!**  

---

### **7. How do you execute raw SQL queries in Laravel?**  
Use the **DB facade**:  

```php
$users = DB::select('SELECT * FROM users WHERE active = ?', [1]);
```
For non-select queries:  
```php
DB::statement('UPDATE users SET status = "active" WHERE id = ?', [10]);
```
📌 **When to use?**  
- When Laravel's Query Builder/Eloquent **can't handle complex queries**.  
- When using **stored procedures**.  

---

### **8. What are transactions, and when should you use them?**  
🔹 **Transactions** ensure multiple queries **succeed or fail together**.  
🔹 Use them when inserting/updating **related records**.  

**Example:**  
```php
DB::beginTransaction();
try {
    Order::create(['user_id' => 1, 'total' => 100]);
    Payment::create(['order_id' => 1, 'amount' => 100]);
    DB::commit();
} catch (\Exception $e) {
    DB::rollBack();
}
```
📌 **Prevents data corruption when part of a process fails.**  

---

### **9. How do Joins improve performance compared to multiple queries?**  
**Joins** fetch related data in **one query**, reducing database trips.  

🔴 **Without Join (multiple queries)**:  
```php
$users = User::all();
foreach ($users as $user) {
    $user->profile; // Executes a separate query for each user
}
```
✅ **With Join (single optimized query)**:  
```php
$users = DB::table('users')
    ->join('profiles', 'users.id', '=', 'profiles.user_id')
    ->select('users.*', 'profiles.bio')
    ->get();
```
📌 **Result:** Fewer queries → Faster performance 🚀  

---

### **10. What is the difference between lazy loading and eager loading in Eloquent?**  
🟡 **Lazy Loading (`$user->profile`)**: Loads related data **when accessed**.  
🔹 **Efficient for small data but causes N+1 queries issue**.  

🟢 **Eager Loading (`User::with('profile')->get()`)**: Loads related data **in advance**.  
🔹 **Prevents the N+1 problem and improves performance**.  

**Example:**  
```php
// Lazy Loading (bad for large datasets)
$users = User::all();
foreach ($users as $user) {
    echo $user->profile->bio; // Extra query for each user
}

// Eager Loading (recommended)
$users = User::with('profile')->get();
foreach ($users as $user) {
    echo $user->profile->bio; // No extra queries
}
```

✅ **Use eager loading (`with()`) whenever possible for better performance.**  

---

### **💡 Summary of Key Points**
| Feature | Query Builder | Eloquent ORM |
|---------|--------------|--------------|
| **Performance** | Faster | Slower (but more readable) |
| **Complex Queries** | More Flexible | Less Flexible |
| **Models Required?** | ❌ No | ✅ Yes |
| **Relationships** | Manual Joins | Built-in (`hasOne`, `belongsTo`) |
| **Best Use Case** | Large datasets, Aggregations | Simple CRUD, Object-Oriented Data Handling |

🚀 **Optimize Laravel Queries By**:  
✔ Using **Eager Loading** to prevent **N+1**.  
✔ Using **Chunking** for large datasets.  
✔ Using **Caching** to reduce DB queries.  
✔ Using **Joins** instead of multiple queries.  
✔ Using **Query Builder** when performance matters.  

Would you like examples of **specific optimizations** for your use case? 😊