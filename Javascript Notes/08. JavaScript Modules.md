Here is **Section 8: JavaScript Modules** with explanations and examples.

---

# **8. JavaScript Modules**  

JavaScript modules allow code to be **organized, reusable, and maintainable**. This section covers CommonJS vs ES Modules and Dynamic Imports.

---

## **8.1 CommonJS vs ES Modules**  

### **CommonJS (CJS) Modules**  
- **Used in Node.js**
- **Synchronous (`require`)**
- **Exports as `module.exports` or `exports`**

#### **Example: CommonJS Module (`math.js`)**
```javascript
// Export functions
function add(a, b) {
    return a + b;
}
function subtract(a, b) {
    return a - b;
}

module.exports = { add, subtract };
```

#### **Example: Importing a CommonJS Module (`app.js`)**
```javascript
const math = require('./math');

console.log(math.add(5, 3)); // ‚úÖ 8
console.log(math.subtract(10, 4)); // ‚úÖ 6
```

‚úÖ **CommonJS is still widely used in Node.js but lacks tree-shaking and is synchronous.**  

---

### **ES Modules (ESM)**
- **Used in modern JavaScript (Browsers & Node.js)**
- **Asynchronous (`import`)**
- **Exports with `export` or `export default`**

#### **Example: ES Module (`math.js`)**
```javascript
// Named exports
export function add(a, b) {
    return a + b;
}

export function subtract(a, b) {
    return a - b;
}
```

#### **Example: Importing an ES Module (`app.js`)**
```javascript
import { add, subtract } from './math.js';

console.log(add(5, 3)); // ‚úÖ 8
console.log(subtract(10, 4)); // ‚úÖ 6
```
‚úÖ **Advantages of ES Modules:**  
- Supports **tree shaking** (removes unused code).  
- Works **natively in browsers** (via `<script type="module">`).  

üîπ **Default Export in ES Modules:**  
```javascript
// `math.js`
export default function multiply(a, b) {
    return a * b;
}

// `app.js`
import multiply from './math.js';
console.log(multiply(5, 2)); // ‚úÖ 10
```

---

## **8.2 Dynamic Imports**  

Dynamic imports allow **lazy loading** of modules **only when needed**, improving performance.

#### **Example: Using `import()`**
```javascript
// Load module dynamically
async function loadMath() {
    const math = await import('./math.js');
    console.log(math.add(2, 3)); // ‚úÖ 5
}

loadMath();
```
‚úÖ **Why Use Dynamic Imports?**  
- **Reduces initial page load time** (loads only when required).  
- **Used in code splitting & lazy loading** (e.g., React, Webpack).  

---

### **Summary Table**  

| Feature | CommonJS | ES Modules | Dynamic Import |
|---------|---------|------------|---------------|
| Syntax | `require()` | `import` | `import()` |
| Execution | Synchronous | Asynchronous | Asynchronous |
| Used In | Node.js | Browsers & Node.js | Browsers & Node.js |
| Exporting | `module.exports` | `export` / `export default` | N/A |
| Importing | `require('./file')` | `import { } from './file.js'` | `import('./file.js')` |
| Supports Lazy Loading? | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes |

---

This concludes **Section 8: JavaScript Modules**. ‚úÖ  

Would you like me to continue with **Section 9: Asynchronous JavaScript**? üöÄ