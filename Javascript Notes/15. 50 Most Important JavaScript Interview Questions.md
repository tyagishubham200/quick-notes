Here are **50 Most Important JavaScript Interview Questions**, categorized for easier reference.  

---

## **1. JavaScript Basics**  
---

### **1. What are the differences between `var`, `let`, and `const`?**  
| Feature   | `var` | `let` | `const` |
|-----------|-------|-------|---------|
| Scope    | Function-scoped | Block-scoped | Block-scoped |
| Redeclaration | Allowed | Not allowed | Not allowed |
| Reassignment | Allowed | Allowed | Not allowed |
| Hoisting | Hoisted with `undefined` | Hoisted but not initialized | Hoisted but not initialized |

Example:
```js
var x = 10;
let y = 20;
const z = 30;

x = 40; // ✅ Allowed
y = 50; // ✅ Allowed
z = 60; // ❌ Error (const cannot be reassigned)
```

---

### **2. What is hoisting in JavaScript?**  
Hoisting is JavaScript's behavior of moving function and variable **declarations** to the top of their scope before execution.

Example:
```js
console.log(a); // undefined (hoisting)
var a = 5;

console.log(b); // ReferenceError (hoisted but not initialized)
let b = 10;
```
- **`var` is hoisted** but initialized as `undefined`.
- **`let` and `const` are hoisted** but remain in a **temporal dead zone** until initialized.

---

### **3. What is the difference between `undefined` and `null`?**  
- **`undefined`**: A variable that has been declared but not assigned a value.
- **`null`**: A value that represents "no value" or "empty value" and is **explicitly assigned**.

Example:
```js
let a;
console.log(a); // undefined

let b = null;
console.log(b); // null
```

---

### **4. What are the different data types in JavaScript?**  
JavaScript has **7 primitive types** and **1 non-primitive type**:

#### **Primitive Types** (immutable):
- `string`
- `number`
- `boolean`
- `null`
- `undefined`
- `symbol`
- `bigint`

#### **Non-Primitive Type**:
- `object` (includes arrays, functions, and objects)

Example:
```js
let str = "Hello"; // string
let num = 10; // number
let bool = true; // boolean
let obj = { key: "value" }; // object
```

---

### **5. What is the difference between `==` and `===` in JavaScript?**  
| Operator | Description |
|----------|-------------|
| `==` | Loose equality (checks **value only**, performs type conversion) |
| `===` | Strict equality (checks **both value and type**) |

Example:
```js
console.log(5 == "5"); // true (type conversion)
console.log(5 === "5"); // false (different types)
```

---

### **6. What is the difference between `map()`, `forEach()`, `filter()`, and `reduce()`?**  

| Method      | Purpose |
|------------|---------|
| `map()`    | Creates a **new array** by applying a function to each element. |
| `forEach()`| Iterates over an array **without returning a new array**. |
| `filter()` | Returns a **new array** with elements that satisfy a condition. |
| `reduce()` | Accumulates elements into a **single value**. |

Example:
```js
let numbers = [1, 2, 3, 4, 5];

// map()
let squared = numbers.map(n => n * n);
console.log(squared); // [1, 4, 9, 16, 25]

// forEach()
numbers.forEach(n => console.log(n * 2)); // Logs 2, 4, 6, 8, 10

// filter()
let evens = numbers.filter(n => n % 2 === 0);
console.log(evens); // [2, 4]

// reduce()
let sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum); // 15
```

---

### **7. What are truthy and falsy values in JavaScript?**  
#### **Falsy values** (evaluate to `false` in Boolean contexts):
- `false`
- `0`
- `""` (empty string)
- `null`
- `undefined`
- `NaN`

#### **Truthy values** (everything else, including empty objects and arrays):
- `"hello"`
- `42`
- `[]` (empty array)
- `{}` (empty object)

Example:
```js
if (0) console.log("Falsy"); // Won't execute
if ("hello") console.log("Truthy"); // Will execute
```

---

### **8. How does the `typeof` operator work?**  
`typeof` returns the **data type** of a variable as a string.

Example:
```js
console.log(typeof "hello"); // "string"
console.log(typeof 42); // "number"
console.log(typeof null); // "object" (JavaScript bug)
console.log(typeof undefined); // "undefined"
console.log(typeof {}); // "object"
console.log(typeof function(){}); // "function"
```

---

### **9. What are template literals, and how do they work?**  
Template literals allow **multi-line strings** and **interpolation** using backticks (`` ` ``) instead of quotes.

Example:
```js
const name = "John";
const greeting = `Hello, ${name}! Welcome.`;
console.log(greeting); // "Hello, John! Welcome."

// Multi-line string
const message = `
  This is line 1
  This is line 2
`;
console.log(message);
```

---

### **10. What is the purpose of the `"use strict"` directive?**  
`"use strict"` enables **strict mode**, which helps catch common JavaScript errors by enforcing stricter parsing and error handling.

#### **Benefits of `"use strict"`:**
1. Prevents accidental global variable creation.
2. Disallows duplicate parameter names.
3. Throws errors on assignment to read-only properties.
4. Eliminates `this` coercion to `window` in functions.

Example:
```js
"use strict";

x = 5; // ❌ ReferenceError: x is not defined
```


---

## **2. Functions & Scope**  
---

### **11. What is the difference between function expressions and function declarations?**  

| Feature | Function Declaration | Function Expression |
|---------|----------------------|---------------------|
| **Syntax** | `function funcName() {}` | `const funcName = function() {};` |
| **Hoisting** | Hoisted (can be called before declaration) | Not hoisted (cannot be called before declaration) |
| **Naming** | Must have a name | Can be anonymous or named |

Example:
```js
// Function Declaration
sayHello(); // ✅ Works due to hoisting
function sayHello() {
  console.log("Hello!");
}

// Function Expression
greet(); // ❌ Error: Cannot access before initialization
const greet = function() {
  console.log("Hi!");
};
```

---

### **12. What is closure in JavaScript? Provide an example.**  
A **closure** is a function that **remembers** the variables from its **lexical scope**, even when the function is executed outside that scope.

Example:
```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}

const counter = outer();
counter(); // 1
counter(); // 2
counter(); // 3
```
Here, `inner()` has access to `count` even after `outer()` has finished executing.

---

### **13. What is the difference between `call()`, `apply()`, and `bind()`?**  

| Method | Purpose |
|--------|---------|
| `call()` | Calls a function with a specific `this` value and arguments passed individually. |
| `apply()` | Calls a function with a specific `this` value and arguments passed as an **array**. |
| `bind()` | Returns a new function with a specific `this` value, without invoking it immediately. |

Example:
```js
const person = {
  name: "Alice",
};

function greet(age, city) {
  console.log(`Hello, my name is ${this.name}, I'm ${age} years old from ${city}.`);
}

greet.call(person, 25, "New York"); // call()
greet.apply(person, [25, "New York"]); // apply()
const boundGreet = greet.bind(person, 25, "New York");
boundGreet(); // bind()
```

---

### **14. What are arrow functions, and how do they differ from regular functions?**  

| Feature | Regular Function | Arrow Function |
|---------|-----------------|---------------|
| `this` Binding | Dynamic (`this` depends on how function is called) | Lexical (`this` inherits from surrounding scope) |
| Arguments Object | Available (`arguments`) | Not available |
| Usage as Constructor | Can be used with `new` | Cannot be used with `new` |

Example:
```js
// Regular function
function sayHello() {
  console.log(this);
}

// Arrow function
const sayHi = () => {
  console.log(this);
};
```
- Arrow functions **do not** have their own `this` and take `this` from their **surrounding scope**.

---

### **15. What is recursion in JavaScript? Provide an example.**  
Recursion is when a function **calls itself** until a base condition is met.

Example: Factorial Calculation
```js
function factorial(n) {
  if (n === 1) return 1; // Base case
  return n * factorial(n - 1); // Recursive case
}

console.log(factorial(5)); // 120
```

---

### **16. What are first-class and higher-order functions?**  

- **First-class functions**: Functions are treated like variables (can be assigned, passed, and returned).  
- **Higher-order functions**: Functions that take another function as an argument or return a function.

Example:
```js
// First-class function
const sayHello = function() {
  return "Hello!";
};
console.log(sayHello());

// Higher-order function
function operate(fn, a, b) {
  return fn(a, b);
}

const add = (x, y) => x + y;
console.log(operate(add, 3, 5)); // 8
```

---

### **17. What is an IIFE (Immediately Invoked Function Expression)?**  
An **IIFE** is a function that executes immediately after being defined.

Syntax:
```js
(function() {
  console.log("I am an IIFE!");
})();
```
- Used to **avoid polluting the global scope**.

---

### **18. What are generator functions in JavaScript?**  
Generator functions (`function*`) allow **pausing** and **resuming** execution using the `yield` keyword.

Example:
```js
function* countUp() {
  yield 1;
  yield 2;
  yield 3;
}

const counter = countUp();
console.log(counter.next().value); // 1
console.log(counter.next().value); // 2
console.log(counter.next().value); // 3
console.log(counter.next().done); // true
```

---

### **19. What is the difference between function scope and block scope?**  

| Scope | Description |
|-------|-------------|
| **Function Scope** | Variables declared with `var` are accessible throughout the function. |
| **Block Scope** | Variables declared with `let` or `const` are only accessible inside the block `{}`. |

Example:
```js
function test() {
  if (true) {
    var a = 10;
    let b = 20;
  }
  console.log(a); // ✅ 10 (function-scoped)
  console.log(b); // ❌ ReferenceError (block-scoped)
}
test();
```

---

### **20. What is memoization, and how is it used in JavaScript?**  
Memoization is a technique for **caching** function results to **avoid redundant calculations**.

Example:
```js
function memoize(fn) {
  let cache = {};
  return function(n) {
    if (n in cache) {
      console.log("Fetching from cache");
      return cache[n];
    } else {
      console.log("Calculating result");
      let result = fn(n);
      cache[n] = result;
      return result;
    }
  };
}

const square = memoize(n => n * n);
console.log(square(5)); // Calculating result -> 25
console.log(square(5)); // Fetching from cache -> 25
```
- Useful for **expensive computations** like Fibonacci series.

---

## **3. Objects & Prototypes**  
---

### **21. What is the difference between shallow copy and deep copy in JavaScript?**  

| Type | Description |
|------|-------------|
| **Shallow Copy** | Copies only the first level of an object; nested objects remain **referenced**. |
| **Deep Copy** | Creates an independent copy of all levels, including nested objects. |

Example:
```js
// Shallow Copy
const obj1 = { a: 1, b: { c: 2 } };
const shallowCopy = { ...obj1 };
shallowCopy.b.c = 42;
console.log(obj1.b.c); // 42 (modified because it's still referenced)

// Deep Copy using JSON
const deepCopy = JSON.parse(JSON.stringify(obj1));
deepCopy.b.c = 99;
console.log(obj1.b.c); // 42 (not modified)
```
🔹 **Shallow Copy Methods:** `Object.assign()`, spread operator `{...obj}`  
🔹 **Deep Copy Methods:** `JSON.parse(JSON.stringify(obj))`, `structuredClone()`, recursive function, libraries like Lodash (`_.cloneDeep`)

---

### **22. How do you clone an object in JavaScript?**  
You can clone an object using different methods:

```js
// Shallow Copy
const obj = { a: 1, b: { c: 2 } };

// 1. Spread Operator
const copy1 = { ...obj };

// 2. Object.assign()
const copy2 = Object.assign({}, obj);

// Deep Copy
// 3. JSON method (only works for simple objects)
const deepCopy1 = JSON.parse(JSON.stringify(obj));

// 4. structuredClone() (best method)
const deepCopy2 = structuredClone(obj);
```
---

### **23. What is prototypal inheritance?**  
**Prototypal inheritance** allows objects to inherit properties and methods from a **prototype**.

Example:
```js
const parent = {
  greet() {
    console.log("Hello!");
  },
};

const child = Object.create(parent); // Inherits from parent
child.greet(); // Hello!
```
- Every object in JavaScript has an internal property **`[[Prototype]]`** that links to another object.
- Prototypes allow for **method sharing** and **memory efficiency**.

---

### **24. How does `Object.create()` work?**  
`Object.create(proto)` creates a new object that **inherits** from `proto`.

Example:
```js
const animal = {
  speak() {
    console.log("I can make a sound");
  },
};

const dog = Object.create(animal);
dog.bark = function() {
  console.log("Woof!");
};

dog.speak(); // Inherited: I can make a sound
dog.bark();  // Woof!
```
- The `dog` object inherits methods from `animal` without copying them.

---

### **25. What is the difference between `Object.assign()` and spread operator `{...obj}`?**  

| Feature | `Object.assign()` | `{...obj}` (Spread) |
|---------|-----------------|----------------|
| Copy Type | Shallow Copy | Shallow Copy |
| Prototype Retained? | **Yes** | **No** |
| Performance | Slightly slower | Faster |

Example:
```js
const obj = { a: 1, b: 2 };

// Using Object.assign()
const copy1 = Object.assign({}, obj);

// Using spread operator
const copy2 = { ...obj };
```
🔹 **Use spread `{...obj}`** for better readability.  
🔹 **Use `Object.assign()`** when working with prototypes.

---

### **26. What is the prototype chain?**  
The **prototype chain** is the mechanism that allows JavaScript objects to inherit properties and methods from their prototypes.

Example:
```js
const obj = {}; // Inherits from Object.prototype
console.log(obj.toString()); // Inherited from Object.prototype
```
**Prototype Chain Example:**
```
obj → Object.prototype → null
```
- If a property/method **is not found** on an object, JavaScript **looks up** the prototype chain.

---

### **27. What are getters and setters in JavaScript?**  
**Getters (`get`)** and **Setters (`set`)** allow controlled access to object properties.

Example:
```js
const person = {
  firstName: "John",
  lastName: "Doe",

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },

  set fullName(name) {
    [this.firstName, this.lastName] = name.split(" ");
  },
};

console.log(person.fullName); // John Doe
person.fullName = "Alice Smith";
console.log(person.firstName); // Alice
```
- **`get`** defines a property that behaves like a method.
- **`set`** allows validation before modifying a value.

---

### **28. How do you check if an object has a property?**  
You can check if an object has a property in three ways:

#### **1. Using `hasOwnProperty()`**
```js
const obj = { a: 1 };
console.log(obj.hasOwnProperty("a")); // true
console.log(obj.hasOwnProperty("b")); // false
```

#### **2. Using `in` operator**
```js
console.log("a" in obj); // true
console.log("b" in obj); // false
```
🔹 `in` checks **inherited properties** too.

#### **3. Using `Object.hasOwn()` (ES2022)**
```js
console.log(Object.hasOwn(obj, "a")); // true
```
- **Best Method:** `hasOwnProperty()` for older browsers, `Object.hasOwn()` for modern usage.

---

## **4. Asynchronous JavaScript**  
---

### **29. What is the difference between synchronous and asynchronous JavaScript?**  

| Type | Description | Example |
|------|-------------|---------|
| **Synchronous** | Code executes **line by line**; one task **must complete** before the next starts. | `console.log("A"); console.log("B"); console.log("C");` |
| **Asynchronous** | Tasks run in the **background** without blocking execution, allowing the next task to proceed. | `setTimeout(() => console.log("A"), 1000); console.log("B");` |

**Example:**
```js
console.log("Start");
setTimeout(() => console.log("Async Task"), 1000);
console.log("End");
```
**Output:**
```
Start
End
Async Task
```

---

### **30. What is the difference between `setTimeout()` and `setInterval()`?**  

| Function | Description |
|----------|-------------|
| `setTimeout(callback, delay)` | Executes the `callback` **once** after `delay` milliseconds. |
| `setInterval(callback, interval)` | Executes the `callback` **repeatedly** every `interval` milliseconds. |

**Example:**
```js
setTimeout(() => console.log("Hello after 2 seconds"), 2000);
setInterval(() => console.log("Repeats every 1 second"), 1000);
```
**Stopping `setInterval()`:**
```js
let interval = setInterval(() => console.log("Running..."), 1000);
setTimeout(() => clearInterval(interval), 5000);
```

---

### **31. What is the event loop in JavaScript?**  
The **event loop** manages asynchronous tasks by handling the **call stack**, **task queue**, and **microtask queue**.

**Flow:**
1. Executes **synchronous code** first (Call Stack).
2. Handles **microtasks** (Promises, `queueMicrotask()`).
3. Executes **macrotasks** (Timers, `setTimeout()`, `setInterval()`, `fetch()`).
4. Repeats the process.

**Example:**
```js
console.log("Start");

setTimeout(() => console.log("Timeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("End");
```
**Output:**
```
Start
End
Promise
Timeout
```
**Why?**  
- **Synchronous** tasks (`console.log()`) run first.
- **Microtasks (Promise)** run before **macrotasks (setTimeout)**.

---

### **32. What is a callback function?**  
A **callback function** is a function **passed as an argument** to another function and executed later.

**Example:**
```js
function greet(name, callback) {
  console.log("Hello, " + name);
  callback();
}

function goodbye() {
  console.log("Goodbye!");
}

greet("Alice", goodbye);
```
**Output:**
```
Hello, Alice
Goodbye!
```
🔹 Used in **asynchronous operations** like `setTimeout()`, `fetch()`, and event listeners.

---

### **33. What are Promises in JavaScript?**  
A **Promise** represents an asynchronous operation that can be:  
✅ `resolved` → Operation successful  
❌ `rejected` → Operation failed  

**Example:**
```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("Success!"), 2000);
});

myPromise.then((result) => console.log(result)).catch((error) => console.log(error));
```
**States of a Promise:**
- `pending` → Initial state
- `fulfilled` → `resolve()` is called
- `rejected` → `reject()` is called

---

### **34. What are async/await in JavaScript?**  
**`async/await`** is a cleaner way to handle Promises.

**Example:**
```js
async function fetchData() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/todos/1");
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.log("Error:", error);
  }
}
fetchData();
```
🔹 **`await` pauses execution** until the Promise resolves.  
🔹 **Requires `async` function.**

---

### **35. What is the difference between microtasks and macrotasks?**  

| **Task Type** | **Examples** | **Execution Order** |
|--------------|-------------|----------------------|
| **Microtasks** | `Promise.then()`, `queueMicrotask()` | **Executed first** after synchronous code |
| **Macrotasks** | `setTimeout()`, `setInterval()`, `fetch()` | **Executed after** microtasks |

**Example:**
```js
console.log("Start");

setTimeout(() => console.log("Timeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("End");
```
**Output:**
```
Start
End
Promise
Timeout
```
🔹 Microtasks **(`Promise.then()`) run before** macrotasks **(`setTimeout()`)**.

---

### **36. What is `Promise.all()` and `Promise.race()`?**  

| Method | Description |
|--------|-------------|
| `Promise.all([p1, p2])` | Resolves when **all promises** resolve. Fails if **any** fail. |
| `Promise.race([p1, p2])` | Resolves when **any one** promise resolves. |

**Example:**
```js
const p1 = new Promise(resolve => setTimeout(() => resolve("P1 done"), 1000));
const p2 = new Promise(resolve => setTimeout(() => resolve("P2 done"), 500));

Promise.all([p1, p2]).then(console.log); // ["P2 done", "P1 done"]
Promise.race([p1, p2]).then(console.log); // "P2 done" (first resolved)
```

---

### **37. How does the `fetch()` API work?**  
The `fetch()` API makes HTTP requests and **returns a Promise**.

**Example:**
```js
fetch("https://jsonplaceholder.typicode.com/todos/1")
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.log("Error:", error));
```
**Using `async/await`:**
```js
async function getData() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/todos/1");
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.log("Error:", error);
  }
}
getData();
```
🔹 **Returns a Promise**  
🔹 **Default method is `GET`**  
🔹 **Use `.json()` to parse JSON responses**  

---

## **5. DOM & Events**  
---

### **38. What is the difference between `document.getElementById()` and `document.querySelector()`?**  

| Method | Selection Criteria | Returns | Example |
|--------|--------------------|---------|---------|
| `getElementById("id")` | Selects an element by its `id` | A **single element** | `document.getElementById("myDiv")` |
| `querySelector("selector")` | Selects the **first matching** element based on a CSS selector | A **single element** | `document.querySelector(".className")` or `document.querySelector("#id")` |

**Example:**
```js
let el1 = document.getElementById("myDiv"); // Selects element with ID 'myDiv'
let el2 = document.querySelector("#myDiv"); // Also selects element with ID 'myDiv'
let el3 = document.querySelector(".myClass"); // Selects first element with class 'myClass'
```
🔹 **`querySelector()` is more flexible** because it allows **CSS selectors**.

---

### **39. What is event delegation in JavaScript?**  
**Event delegation** is a technique where you **add an event listener to a parent element** instead of multiple child elements.

🔹 **Why use it?**
- Improves **performance** when handling many child elements.
- Works for **dynamically added elements**.

**Example:**
```js
document.getElementById("parent").addEventListener("click", function (event) {
  if (event.target.classList.contains("child")) {
    console.log("Child clicked:", event.target.textContent);
  }
});
```
✅ Here, **only one event listener** is attached to the parent.  
✅ Works even if new `.child` elements are added dynamically.

---

### **40. What is the difference between event bubbling and event capturing?**  

| Event Flow | Description | Default? |
|------------|-------------|----------|
| **Bubbling** | Event starts from the **target element** and moves **up** to parent elements | ✅ **Default** |
| **Capturing** | Event starts from the **topmost ancestor** and moves **down** to the target | ❌ Requires `{capture: true}` |

**Example:**
```js
document.getElementById("child").addEventListener("click", () => console.log("Child clicked"));
document.getElementById("parent").addEventListener("click", () => console.log("Parent clicked"));
document.body.addEventListener("click", () => console.log("Body clicked"));
```
**Clicking on `child` produces this output (bubbling by default):**
```
Child clicked
Parent clicked
Body clicked
```
🔹 **Event propagates upward** in **bubbling mode**.

To use **capturing mode**, add `{ capture: true }`:
```js
document.getElementById("parent").addEventListener("click", () => console.log("Parent capturing"), { capture: true });
```
---

### **41. How do you stop event propagation?**  
To **stop bubbling or capturing**, use:  

✅ **`event.stopPropagation()`** → Stops event from propagating **further** up/down.  
✅ **`event.stopImmediatePropagation()`** → Stops propagation **and prevents other listeners** on the same element.

**Example:**
```js
document.getElementById("child").addEventListener("click", function (event) {
  console.log("Child clicked");
  event.stopPropagation(); // Stops event from reaching parent
});

document.getElementById("parent").addEventListener("click", () => console.log("Parent clicked"));
```
If you click `child`, **only "Child clicked" appears**, not "Parent clicked".

---

### **42. What is the difference between `innerHTML` and `textContent`?**  

| Property | Description | Example Output |
|----------|-------------|---------------|
| `innerHTML` | Returns **HTML content** (including tags) | `"<b>Hello</b>"` |
| `textContent` | Returns **only text** (ignores HTML tags) | `"Hello"` |

**Example:**
```js
let el = document.getElementById("myDiv");
console.log(el.innerHTML);   // "<b>Hello</b>"
console.log(el.textContent); // "Hello"
```
🔹 **Use `textContent`** when you want **plain text** (safer for security).  
🔹 **Use `innerHTML`** when you need to insert **HTML elements dynamically**.

---

### **43. How can you optimize DOM manipulation in JavaScript?**  

**1️⃣ Minimize Reflows & Repaints**  
- **Batch DOM updates** instead of updating one-by-one.  
- Use `documentFragment` for multiple insertions.

```js
let fragment = document.createDocumentFragment();
for (let i = 0; i < 10; i++) {
  let div = document.createElement("div");
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);
}
document.body.appendChild(fragment);
```
🔹 **Improves performance** by reducing layout recalculations.

---

**2️⃣ Use Event Delegation**  
Instead of adding an event listener to **each button**, use a **single listener on a parent**:
```js
document.getElementById("parent").addEventListener("click", function (event) {
  if (event.target.tagName === "BUTTON") {
    console.log("Button clicked:", event.target.textContent);
  }
});
```

---

**3️⃣ Use `classList` Instead of `className`**  
❌ **Slow (Replaces entire class list)**  
```js
element.className = "new-class";
```
✅ **Fast (Modifies individual classes)**  
```js
element.classList.add("new-class");
```

---

**4️⃣ Avoid Unnecessary DOM Lookups**  
Instead of querying elements **multiple times**, store them in variables:
```js
let btn = document.getElementById("myButton");
btn.addEventListener("click", () => console.log("Clicked"));
```

---

**5️⃣ Use `requestAnimationFrame()` for Smooth Animations**  
Instead of `setInterval()`, use `requestAnimationFrame()` to optimize animations:
```js
function animate() {
  console.log("Animating...");
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
```
✅ **Improves performance** by synchronizing with the screen refresh rate.

---

## **6. Performance & Memory Optimization**  
---

### **44. What is debouncing, and how does it work?**  
**Debouncing** is a technique to **delay the execution** of a function until a certain time has passed **since the last time it was called**.  
✅ **Used to prevent excessive function calls** (e.g., API calls on keypress).  

🔹 **Example:** Optimize search input field  
```js
function debounce(func, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => func.apply(this, args), delay);
  };
}

// Usage: Delays API call until user stops typing for 500ms
document.getElementById("search").addEventListener(
  "input",
  debounce((event) => {
    console.log("Searching for:", event.target.value);
  }, 500)
);
```
⏳ **Effect:** Calls function only after the user **stops typing for 500ms**.

---

### **45. What is throttling, and how does it work?**  
**Throttling** ensures a function is called **at most once every X milliseconds**, no matter how many times the event is triggered.  
✅ **Used for optimizing scroll, resize, and mousemove events.**  

🔹 **Example:** Optimize window resizing  
```js
function throttle(func, limit) {
  let lastCall = 0;
  return function (...args) {
    let now = Date.now();
    if (now - lastCall >= limit) {
      lastCall = now;
      func.apply(this, args);
    }
  };
}

// Usage: Limits execution of function to once every 300ms
window.addEventListener(
  "resize",
  throttle(() => {
    console.log("Window resized");
  }, 300)
);
```
🛠 **Effect:** Function executes **at most once every 300ms**, even if resizing happens continuously.

---

### **46. What are memory leaks in JavaScript, and how do you prevent them?**  
A **memory leak** occurs when **objects are no longer needed but are still referenced in memory**, preventing garbage collection.

#### **Common Causes of Memory Leaks & Solutions**  
| Cause | Example | Prevention |
|------|---------|------------|
| **Unused Variables** | `var bigObject = {...};` but never used | Use `let` or `const` instead of `var` |
| **Forgotten Timers** | `setInterval()` keeps running | `clearInterval()` when no longer needed |
| **Detached DOM Elements** | `let el = document.getElementById("myDiv"); el.remove();` but reference remains | Set `el = null` after removal |
| **Global Variables** | `window.leak = {...};` | Avoid unnecessary global variables |
| **Closures Holding References** | Functions keeping references to old variables | Avoid excessive closures |

🔹 **Example Fix: Remove event listeners properly**
```js
function handleClick() {
  console.log("Button clicked");
}

const btn = document.getElementById("myButton");
btn.addEventListener("click", handleClick);

// Prevent memory leak when button is removed
btn.removeEventListener("click", handleClick);
```
🚀 **Result:** Removes the event listener when no longer needed.

---

### **47. How does garbage collection work in JavaScript?**  
JavaScript **automatically frees up memory** when objects are no longer needed, using **garbage collection (GC)**.

#### **Garbage Collection Algorithms**  
1. **Reference Counting**  
   - Each object has a reference count.
   - If count = **0**, it's deleted.
   - **Issue:** Can't handle **circular references**.

2. **Mark-and-Sweep (Used in modern JS engines)**  
   - Starts from **root objects** (e.g., `window`, `document`).
   - **Marks** reachable objects.
   - **Sweeps away** unmarked objects.

🔹 **Example:**
```js
let obj = { name: "John" }; // obj is in memory
obj = null; // No reference, eligible for garbage collection
```
🛠 **Tip:** Assign `null` to objects when no longer needed to allow GC.

---

### **48. What is reflow and repaint in the browser?**  
| Concept | Description | Causes |
|---------|------------|--------|
| **Reflow** | Browser recalculates layout (geometry of elements) | Adding/removing DOM elements, changing dimensions, font size, etc. |
| **Repaint** | Browser redraws elements without changing layout | Changing color, background, visibility, shadows, etc. |

🔹 **Minimizing Reflow & Repaint**  
✅ Use **`classList.add()`** instead of modifying styles directly:  
```js
document.getElementById("box").classList.add("hidden"); // ✅ Efficient
```
✅ **Batch DOM updates** using `documentFragment`:  
```js
let fragment = document.createDocumentFragment();
for (let i = 0; i < 10; i++) {
  let div = document.createElement("div");
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);
}
document.body.appendChild(fragment);
```
✅ **Use CSS animations instead of JavaScript animations** for better performance.

---

## **7. Miscellaneous & Advanced Topics**  
---

### **49. What are Web Workers in JavaScript?**  
**Web Workers** allow JavaScript to run scripts in the **background**, separate from the main thread.  
✅ **Used to prevent UI freezing and improve performance** for intensive tasks like image processing or large calculations.  

🔹 **Types of Web Workers**:  
1. **Dedicated Web Workers** – Used by a single script.  
2. **Shared Web Workers** – Can be shared between multiple scripts.  
3. **Service Workers** – Used for caching and offline experiences.  

🔹 **Example: Creating and using a Web Worker**  
🔸 **worker.js** (Worker file)  
```js
// Background thread logic
self.onmessage = function (event) {
  let result = event.data * 2; // Perform computation
  self.postMessage(result); // Send result back
};
```
🔸 **main.js** (Main thread)  
```js
const worker = new Worker("worker.js"); // Create Worker

worker.postMessage(10); // Send data to Worker

worker.onmessage = function (event) {
  console.log("Result from Worker:", event.data); // Output: 20
};

worker.terminate(); // Stop Worker when done
```
🚀 **Benefit:** The computation runs in the background without blocking UI updates.

---

### **50. What is CORS (Cross-Origin Resource Sharing)?**  
**CORS (Cross-Origin Resource Sharing)** is a security mechanism that **controls which external domains** can access resources (APIs, data) from a web server.  

🔹 **By default, browsers block cross-origin requests for security reasons (Same-Origin Policy).**  

#### **How CORS Works**  
- A web server **includes special headers** in the response to allow/restrict requests from other origins.  
- Example of an **allowed CORS request:**  
```http
Access-Control-Allow-Origin: *
```
✅ Allows requests from any domain.  

---

### **CORS Example in JavaScript (`fetch`)**  
🔸 **Making a request to an API with CORS enabled**  
```js
fetch("https://api.example.com/data", {
  method: "GET",
  headers: { "Content-Type": "application/json" },
})
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("CORS error:", error));
```
🛠 **If CORS is not enabled on the server, the request will fail with a CORS error.**

---

### **How to Enable CORS on a Server**  
✅ **Example: Enabling CORS in Express.js**  
```js
const express = require("express");
const cors = require("cors");
const app = express();

app.use(cors()); // Enables CORS for all requests

app.get("/data", (req, res) => {
  res.json({ message: "CORS enabled!" });
});

app.listen(3000, () => console.log("Server running on port 3000"));
```
🔹 **Restricting CORS to specific domains:**  
```js
app.use(
  cors({
    origin: "https://allowed-domain.com",
  })
);
```
🚀 **Benefit:** Securely allows external sites to access APIs while maintaining control over who can connect.

---