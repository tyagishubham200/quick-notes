Here is **Section 4: Functional Programming in JavaScript** with explanations and examples.  

---

# **4. Functional Programming in JavaScript**  

Functional Programming (FP) is a programming paradigm that treats functions as first-class citizens, avoids shared state, and emphasizes immutability. It helps create predictable, reusable, and maintainable code.  

---

## **4.1 First-Class & Higher-Order Functions**  

### **First-Class Functions**  
In JavaScript, functions are **first-class citizens**, meaning they can be assigned to variables, passed as arguments, and returned from other functions.  

### **Example:**  
```javascript
// Assigning a function to a variable
const greet = function(name) {
    return `Hello, ${name}`;
};

console.log(greet("Alice")); // Hello, Alice
```

---

### **Higher-Order Functions (HOFs)**  
A **higher-order function** is a function that either:  
1. Takes another function as an argument, or  
2. Returns a function  

### **Example:**
```javascript
function multiplyBy(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = multiplyBy(2);
console.log(double(5)); // 10
```
‚úÖ **Use Case:**  
- **Array methods** like `map`, `filter`, `reduce` use HOF principles.  

---

## **4.2 Pure Functions & Side Effects**  

### **Pure Functions**  
A **pure function** always returns the same output for the same input and has **no side effects**.  

### **Example:**  
```javascript
function add(a, b) {
    return a + b;  // No external changes, always same output for same input
}

console.log(add(2, 3)); // 5
console.log(add(2, 3)); // 5
```
‚úÖ **Advantages of Pure Functions:**  
- Easier to debug and test  
- No unexpected behavior  

---

### **Side Effects**  
A **side effect** occurs when a function modifies a variable outside its scope, changes global state, or interacts with I/O.  

### **Example of Side Effect:**
```javascript
let total = 0;

function addToTotal(value) {
    total += value;  // Modifying external state (bad practice)
}

addToTotal(5);
console.log(total); // 5 (depends on external variable)
```
‚ùå **Avoid side effects** unless necessary.  

---

## **4.3 Immutability**  

**Immutability** means data **cannot be changed** after creation. Instead of modifying an object, create a new one.  

### **Mutable (Bad Practice):**  
```javascript
let user = { name: "Alice", age: 25 };
user.age = 26; // Modifying existing object
console.log(user); // { name: "Alice", age: 26 }
```

### **Immutable (Good Practice):**  
```javascript
const user = { name: "Alice", age: 25 };

const updatedUser = { ...user, age: 26 }; // Creating a new object
console.log(updatedUser); // { name: "Alice", age: 26 }
console.log(user); // Original object remains unchanged
```
‚úÖ **Benefits of Immutability:**  
- Prevents unintended modifications  
- Helps with debugging and state management (e.g., in **React**)  

---

## **4.4 Currying**  

**Currying** transforms a function with multiple arguments into a sequence of functions, each taking a single argument.  

### **Example (Non-Curried Function):**  
```javascript
function multiply(a, b) {
    return a * b;
}

console.log(multiply(2, 3)); // 6
```

### **Example (Curried Function):**  
```javascript
function curriedMultiply(a) {
    return function(b) {
        return a * b;
    };
}

const double = curriedMultiply(2); 
console.log(double(3)); // 6
```
‚úÖ **Use Case:**  
- Useful in **functional composition**  
- Improves **reusability** of functions  

---

## **4.5 Memoization**  

**Memoization** is an optimization technique that **caches function results** to avoid redundant calculations.  

### **Example:**  
```javascript
function memoize(fn) {
    let cache = {};
    return function(...args) {
        let key = JSON.stringify(args);
        if (cache[key]) {
            return cache[key];  // Return cached result
        }
        cache[key] = fn(...args);
        return cache[key];
    };
}

const factorial = memoize(function(n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
});

console.log(factorial(5)); // Computed: 120
console.log(factorial(5)); // Cached: 120
```
‚úÖ **Use Case:**  
- **Performance optimization** (e.g., expensive calculations)  
- Used in **React hooks (`useMemo`)**  

---

### **Summary Table**  

| Concept        | Explanation | Example Use Case |
|---------------|------------|------------------|
| **First-Class Functions** | Functions are treated as variables | Passing functions as arguments |
| **Higher-Order Functions** | Functions that accept/return other functions | `map()`, `filter()`, `reduce()` |
| **Pure Functions** | No side effects, always same output | Math calculations |
| **Side Effects** | Modifies external state | Updating global variables |
| **Immutability** | Data cannot be modified, only copied | React state management |
| **Currying** | Converts multi-argument functions into single-argument ones | Function reusability |
| **Memoization** | Caches results for performance | Fibonacci calculation |

---

This concludes **Section 4: Functional Programming in JavaScript**. Let me know if you'd like any modifications or if I should proceed with **Section 5: Asynchronous JavaScript**. üöÄ