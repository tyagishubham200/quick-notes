Hereâ€™s **Section 2: Advanced JavaScript Concepts** with detailed explanations.  

---

# **2. Advanced JavaScript Concepts**

## **2.1 Execution Context**  

Execution Context (EC) determines how JavaScript code is executed. It has three phases:  
1. **Creation Phase (Memory Allocation)**  
   - `this` is set  
   - Variables declared with `var` are hoisted with `undefined`  
   - Functions are hoisted entirely  
2. **Execution Phase (Code Execution)**  
   - Code runs line by line  
   - Variables are assigned values  
2. **Destruction Phase (Garbage Collection)**  
   - When execution is finished, the context is removed from the stack
  
### **Example:**
```javascript
console.log(x); // undefined (hoisted)
var x = 5;
console.log(x); // 5
```

---

## **2.2 Scope & Closures**  

### **2.2.1 Scope**  
Scope defines the visibility of variables.  
- **Global Scope**: Accessible everywhere.  
- **Function Scope**: Variables declared inside a function are not accessible outside.  
- **Block Scope (ES6 - `let`, `const`)**: Limited to `{}` blocks.  

### **Example:**
```javascript
let a = 10; // Global Scope
function test() {
    let b = 20; // Function Scope
    console.log(a); // Accessible
    console.log(b); // Accessible
}
test();
console.log(b); // Error: b is not defined
```

---

### **2.2.2 Closures**  
A closure is a function that remembers the variables from its outer function even after the outer function has executed.

### **Example:**
```javascript
function outer() {
    let count = 0;
    return function inner() {
        count++;
        console.log(count);
    };
}
const counter = outer();
counter(); // 1
counter(); // 2
```
Here, `inner` function retains access to `count` even after `outer` has executed.

---

## **2.3 Hoisting**  

JavaScript moves function and variable declarations to the top of their scope before execution.

### **Example:**  
```javascript
console.log(name); // undefined (hoisted)
var name = "John";
```
- Variables declared with `var` are hoisted but initialized as `undefined`.  
- `let` and `const` are hoisted but not initialized.  

**Hoisting with Functions:**  
```javascript
sayHello(); // Works because function declarations are fully hoisted
function sayHello() {
    console.log("Hello!");
}
```

---

## **2.4 Prototypes & Prototype Chain**  

Every JavaScript object has an internal `[[Prototype]]` property. It enables inheritance.

### **Example:**
```javascript
let person = {
    greet: function() {
        console.log("Hello!");
    }
};
let user = Object.create(person);
user.greet(); // Hello! (inherited from person)
```

### **Prototype Chain:**  
If a property/method is not found in an object, JavaScript looks up the prototype chain.

```javascript
console.log(user.toString()); // Inherited from Object.prototype
```

---

## **2.5 Event Loop & Microtask Queue**  

JavaScript is **single-threaded** and uses an **event loop** to handle asynchronous operations.

### **Order of Execution:**
1. **Call Stack** (Executes synchronous code)
2. **Microtask Queue** (Promises, MutationObserver)
3. **Task Queue** (setTimeout, setInterval, fetch)

### **Example:**
```javascript
console.log("Start");

setTimeout(() => console.log("setTimeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("End");
```
**Output:**  
```
Start
End
Promise
setTimeout
```
- `setTimeout` runs after the microtask queue (Promise).

---

## **2.6 Asynchronous JavaScript (Callbacks, Promises, Async/Await)**  

### **2.6.1 Callbacks**  
A function passed as an argument to another function.
```javascript
function fetchData(callback) {
    setTimeout(() => {
        callback("Data received");
    }, 1000);
}
fetchData(data => console.log(data)); // "Data received"
```

---

### **2.6.2 Promises**  
A better way to handle async operations.  
**States:** `Pending â†’ Fulfilled / Rejected`

```javascript
let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Success"), 1000);
});
promise.then(data => console.log(data));
```

**Chaining Promises:**
```javascript
promise
    .then(data => data + "!")
    .then(updatedData => console.log(updatedData))
    .catch(error => console.error(error));
```

---

### **2.6.3 Async/Await**  
A cleaner way to handle promises.
```javascript
async function fetchData() {
    let data = await promise;
    console.log(data);
}
fetchData();
```
**Try-Catch for Error Handling:**
```javascript
async function fetchData() {
    try {
        let data = await fetch("https://api.example.com");
        let json = await data.json();
        console.log(json);
    } catch (error) {
        console.error("Error:", error);
    }
}
```

---

This concludes **Section 2: Advanced JavaScript Concepts**. Let me know if youâ€™d like any modifications, or if I should continue with **Section 3: JavaScript Design Patterns**. ðŸš€