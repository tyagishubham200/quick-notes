Got it! Here is **Section 3: JavaScript Design Patterns** with explanations and examples.  

---

# **3. JavaScript Design Patterns**  

Design patterns are reusable solutions to common problems in software design. They help make code more structured, maintainable, and scalable.  

## **3.1 Module Pattern**  

The **Module Pattern** helps in encapsulating private and public members, avoiding global scope pollution.

### **Example:**  
```javascript
const Module = (function () {
    let privateVar = "I am private";

    function privateMethod() {
        console.log("Accessing private method");
    }

    return {
        publicMethod: function () {
            console.log("Accessing public method");
            privateMethod();
        },
        getPrivateVar: function () {
            return privateVar;
        }
    };
})();

Module.publicMethod();  // Accessing public method, Accessing private method
console.log(Module.getPrivateVar()); // I am private
```
✅ **Use Case:**  
- Avoids global variable pollution  
- Hides implementation details  

---

## **3.2 Factory Pattern**  

The **Factory Pattern** is used to create objects dynamically without specifying their concrete class. It’s useful when dealing with object creation logic that changes frequently.

### **Example:**  
```javascript
function CarFactory(type) {
    if (type === "sedan") {
        return { type: "Sedan", doors: 4 };
    } else if (type === "suv") {
        return { type: "SUV", doors: 5 };
    } else {
        return { type: "Unknown", doors: 0 };
    }
}

const car1 = CarFactory("sedan");
console.log(car1); // { type: "Sedan", doors: 4 }

const car2 = CarFactory("suv");
console.log(car2); // { type: "SUV", doors: 5 }
```
✅ **Use Case:**  
- When object creation logic varies  
- Improves code flexibility  

---

## **3.3 Singleton Pattern**  

The **Singleton Pattern** ensures that only **one instance** of an object is created and provides a single point of access.

### **Example:**  
```javascript
const Singleton = (function () {
    let instance;

    function createInstance() {
        return { name: "I am the only instance" };
    }

    return {
        getInstance: function () {
            if (!instance) {
                instance = createInstance();
            }
            return instance;
        }
    };
})();

const obj1 = Singleton.getInstance();
const obj2 = Singleton.getInstance();

console.log(obj1 === obj2); // true (both refer to the same instance)
```
✅ **Use Case:**  
- Managing configurations  
- Database connections  

---

## **3.4 Observer Pattern**  

The **Observer Pattern** is used when multiple objects (subscribers) need to listen for changes in another object (subject).

### **Example:**  
```javascript
class Subject {
    constructor() {
        this.observers = [];
    }

    subscribe(observer) {
        this.observers.push(observer);
    }

    unsubscribe(observer) {
        this.observers = this.observers.filter(obs => obs !== observer);
    }

    notify(data) {
        this.observers.forEach(observer => observer.update(data));
    }
}

class Observer {
    update(data) {
        console.log("Received data:", data);
    }
}

const subject = new Subject();
const observer1 = new Observer();
const observer2 = new Observer();

subject.subscribe(observer1);
subject.subscribe(observer2);

subject.notify("Event 1"); 
// Observer 1: Received data: Event 1
// Observer 2: Received data: Event 1
```
✅ **Use Case:**  
- Event listeners  
- Messaging systems  

---

## **3.5 Proxy Pattern**  

The **Proxy Pattern** acts as a middle layer between the client and the actual object, controlling access.

### **Example:**
```javascript
const handler = {
    get: function (target, property) {
        return property in target ? target[property] : "Property not found";
    }
};

const person = { name: "Alice", age: 30 };
const proxyPerson = new Proxy(person, handler);

console.log(proxyPerson.name); // Alice
console.log(proxyPerson.age);  // 30
console.log(proxyPerson.address); // Property not found
```
✅ **Use Case:**  
- API request caching  
- Logging or validation before accessing an object  

---

### **Summary Table**

| Pattern        | Purpose | Example Use Case |
|---------------|---------|------------------|
| **Module**    | Encapsulation, avoid global variables | Encapsulating methods and properties |
| **Factory**   | Create objects dynamically | Object creation logic in libraries |
| **Singleton** | Ensure a single instance of an object | Configuration settings |
| **Observer**  | Notify subscribers of changes | Event listeners, real-time updates |
| **Proxy**     | Control access to an object | API request caching, validation |

---

This currently includes only these five patterns because they are among the most commonly used and widely applicable in JavaScript development. However, there are many other design patterns, such as:

- Prototype Pattern
- Strategy Pattern
- Command Pattern
- Decorator Pattern
- Mediator Pattern
- Builder Pattern
- Adapter Pattern
- State Pattern