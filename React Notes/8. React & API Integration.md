# **8️⃣ React & API Integration**  

API integration is crucial for dynamic web applications. React allows you to fetch data using **Fetch API** or **Axios**, handle errors, debounce API calls, and implement features like **infinite scrolling** and **pagination**.

---

## **8.1 Fetch API vs. Axios**  

📌 **Both Fetch API and Axios are used for making HTTP requests, but Axios provides additional features that simplify API handling.**  

| Feature         | Fetch API               | Axios                  |
|---------------|-----------------------|-----------------------|
| **Syntax**      | Verbose                 | Concise               |
| **Response Handling** | Must convert `.json()` | Auto JSON conversion |
| **Error Handling** | Manual `catch` required | Built-in error handling |
| **Request Cancelation** | No built-in support | Supports cancel tokens |
| **Interceptors** | Not available | Available |
| **Default Headers** | Manual setup | Easy configuration |

✅ **Example: Fetch API**  
```tsx
const fetchData = async () => {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/posts");
    if (!response.ok) throw new Error("Failed to fetch");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Error fetching data:", error);
  }
};

fetchData();
```

✅ **Example: Axios**  
```tsx
import axios from "axios";

const fetchData = async () => {
  try {
    const { data } = await axios.get("https://jsonplaceholder.typicode.com/posts");
    console.log(data);
  } catch (error) {
    console.error("Error fetching data:", error);
  }
};

fetchData();
```

📌 **Why Use Axios?**  
- Automatically parses JSON.  
- Better error handling.  
- Supports interceptors and request cancelation.  

---

## **8.2 Handling API Errors & Loading States**  

When making API requests, it’s essential to handle **loading, success, and error states** properly.

✅ **Example Using `useState` & `useEffect`**  
```tsx
import { useState, useEffect } from "react";
import axios from "axios";

const DataFetcher = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
        setData(response.data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  if (loading) return <p>Loading...</p>;
  if (error) return <p style={{ color: "red" }}>Error: {error}</p>;

  return (
    <ul>
      {data.map((item) => (
        <li key={item.id}>{item.title}</li>
      ))}
    </ul>
  );
};

export default DataFetcher;
```

📌 **Key Takeaways:**  
- `loading`: Ensures a smooth user experience.  
- `error`: Prevents unexpected crashes.  
- `finally`: Runs after success or failure to update state.  

---

## **8.3 Debouncing API Calls**  

Debouncing limits the number of API calls by delaying execution after the last input event.

✅ **Example: Search API with Debounce**  
```tsx
import { useState, useEffect } from "react";
import axios from "axios";

const useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
};

const SearchComponent = () => {
  const [query, setQuery] = useState("");
  const debouncedQuery = useDebounce(query, 500);
  const [results, setResults] = useState([]);

  useEffect(() => {
    if (debouncedQuery) {
      axios
        .get(`https://jsonplaceholder.typicode.com/posts?title_like=${debouncedQuery}`)
        .then((res) => setResults(res.data))
        .catch((err) => console.error(err));
    }
  }, [debouncedQuery]);

  return (
    <div>
      <input type="text" placeholder="Search..." onChange={(e) => setQuery(e.target.value)} />
      <ul>
        {results.map((item) => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
};

export default SearchComponent;
```

📌 **Key Takeaways:**  
- Prevents excessive API calls.  
- Improves performance in search fields.  

---

## **8.4 Infinite Scrolling & Pagination**  

### **🔹 Pagination**  
Pagination loads data in chunks rather than all at once.

✅ **Example: Paginated API Calls**  
```tsx
import { useState, useEffect } from "react";
import axios from "axios";

const PaginatedList = () => {
  const [data, setData] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    setLoading(true);
    axios
      .get(`https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=10`)
      .then((res) => setData(res.data))
      .finally(() => setLoading(false));
  }, [page]);

  return (
    <div>
      <ul>
        {data.map((item) => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
      <button onClick={() => setPage((prev) => prev + 1)} disabled={loading}>
        {loading ? "Loading..." : "Load More"}
      </button>
    </div>
  );
};

export default PaginatedList;
```

📌 **Key Takeaways:**  
- Uses `_page` and `_limit` for pagination.  
- Increases page count to load more data.  

---

### **🔹 Infinite Scrolling**  
Automatically loads new content as the user scrolls down.

✅ **Example: Infinite Scroll API Calls**  
```tsx
import { useState, useEffect } from "react";
import axios from "axios";

const InfiniteScrollList = () => {
  const [data, setData] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    setLoading(true);
    axios
      .get(`https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=10`)
      .then((res) => setData((prev) => [...prev, ...res.data]))
      .finally(() => setLoading(false));
  }, [page]);

  const handleScroll = () => {
    if (window.innerHeight + document.documentElement.scrollTop !== document.documentElement.offsetHeight) return;
    setPage((prev) => prev + 1);
  };

  useEffect(() => {
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  return (
    <ul>
      {data.map((item) => (
        <li key={item.id}>{item.title}</li>
      ))}
      {loading && <p>Loading...</p>}
    </ul>
  );
};

export default InfiniteScrollList;
```

📌 **Key Takeaways:**  
- Listens to scroll events.  
- Automatically loads more data when reaching the bottom.  

---

## **📌 Summary**  
✔ **Fetch API vs. Axios** – Axios is preferred for better features.  
✔ **Error & Loading Handling** – Avoids crashes and bad UX.  
✔ **Debouncing API Calls** – Reduces unnecessary requests.  
✔ **Pagination & Infinite Scrolling** – Optimizes data loading.  

🔥 **Next Topic: 9️⃣ React Performance Optimization**  

Let me know if you need any modifications! 🚀