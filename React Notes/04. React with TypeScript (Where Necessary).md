# **4️⃣ React with TypeScript (Where Necessary)**  

---

## **4.1 TypeScript vs. JavaScript – Why Use TypeScript?**  

### **Why Use TypeScript in React?**  
✅ **Static Typing** – Catches errors at compile-time.  
✅ **Better Code Completion** – Enhanced IntelliSense support.  
✅ **Improved Maintainability** – Helps in larger projects.  
✅ **Refactoring Safety** – Detects incorrect function arguments or prop types.  

📌 **Example of JavaScript vs. TypeScript**  

🔹 **JavaScript (No Type Safety)**  
```jsx
function greet(name) {
  return "Hello, " + name.toUpperCase();
}
console.log(greet(42)); // Runtime error
```

🔹 **TypeScript (Type Safety)**  
```tsx
function greet(name: string): string {
  return "Hello, " + name.toUpperCase();
}
console.log(greet(42)); // Compile-time error ❌
```

---

## **4.2 TypeScript Basic Types in React**  

### **Common TypeScript Types in React**  
| Type | Example |
|------|---------|
| `string` | `let name: string = "React";` |
| `number` | `let count: number = 10;` |
| `boolean` | `let isActive: boolean = true;` |
| `array` | `let names: string[] = ["Alice", "Bob"];` |
| `object` | `let user: { id: number, name: string } = { id: 1, name: "John" };` |
| `union` | `let value: string | number = "hello";` |
| `any` | `let data: any = 5;` (⚠️ Avoid using `any`) |

---

## **4.3 Typing Props and State**  

### **Typing Props in Functional Components**  
```tsx
type ButtonProps = {
  text: string;
  onClick: () => void;
};

const Button: React.FC<ButtonProps> = ({ text, onClick }) => {
  return <button onClick={onClick}>{text}</button>;
};
```
✅ Ensures `text` is a `string` and `onClick` is a function.  

🔹 **Using Props with Optional Values & Default Props**  
```tsx
type UserCardProps = {
  name: string;
  age?: number; // Optional prop
};

const UserCard: React.FC<UserCardProps> = ({ name, age = 25 }) => {
  return <p>{name} is {age} years old.</p>;
};
```

---

### **Typing State in Functional Components**  
```tsx
import { useState } from "react";

const Counter: React.FC = () => {
  const [count, setCount] = useState<number>(0);

  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
};
```
📌 `useState<number>(0)` ensures `count` can only be a `number`.  

---

## **4.4 Typing useRef & useState**  

### **Typing useRef for DOM Elements**  
```tsx
import { useRef, useEffect } from "react";

const InputFocus: React.FC = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (inputRef.current) inputRef.current.focus();
  }, []);

  return <input ref={inputRef} placeholder="Type here..." />;
};
```
📌 `useRef<HTMLInputElement>(null)` ensures `inputRef` refers to an `<input>` element.  

---

## **4.5 Typing Custom Hooks**  

### **Example: Custom Hook for Fetching Data**  
```tsx
import { useState, useEffect } from "react";

type ApiResponse = {
  id: number;
  name: string;
};

const useFetchData = (url: string) => {
  const [data, setData] = useState<ApiResponse[] | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then((result) => {
        setData(result);
        setLoading(false);
      });
  }, [url]);

  return { data, loading };
};

export default useFetchData;
```
📌 `ApiResponse` type ensures API data structure is maintained.  

---

## **4.6 Typing Events (onClick, onChange, etc.)**  

### **Typing onClick Event in Buttons**  
```tsx
const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
  console.log("Button clicked!", event);
};

<button onClick={handleClick}>Click Me</button>;
```

### **Typing onChange Event in Input Fields**  
```tsx
const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  console.log("Value:", event.target.value);
};

<input type="text" onChange={handleChange} />;
```

📌 Ensures proper event typing, preventing runtime errors.  

---

## **4.7 Typing useReducer & Context API**  

### **Typing useReducer**  
```tsx
import { useReducer } from "react";

type State = { count: number };
type Action = { type: "increment" | "decrement" };

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
};

const Counter: React.FC = () => {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
    </>
  );
};
```

📌 `State` and `Action` types ensure type safety in reducer logic.  

---

### **Typing Context API**  
```tsx
import { createContext, useContext, useState } from "react";

type Theme = "light" | "dark";

interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | null>(null);

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<Theme>("light");

  const toggleTheme = () => setTheme((prev) => (prev === "light" ? "dark" : "light"));

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) throw new Error("useTheme must be used within a ThemeProvider");
  return context;
};
```
📌 Ensures proper type safety for `useContext`, preventing `undefined` errors.  

---

🔥 **Next Topic: 5️⃣ React Interview Questions & Best Practices**  

Would you like me to add more details or move to the next section? 🚀