# **🔟 React Interview Preparation Topics**  

This section covers important **React interview topics**, including **core concepts, optimization techniques, and React internals**. These topics help in cracking **React job interviews** for beginner to advanced levels.  

---

## **🔹 Differences Between React & Angular/Vue**  
| Feature            | React           | Angular          | Vue.js          |
|--------------------|----------------|------------------|----------------|
| Type              | Library         | Framework       | Framework      |
| Language         | JavaScript/JSX  | TypeScript      | JavaScript     |
| Architecture     | Component-based | MVC             | Component-based |
| State Management | Redux, Context  | NgRx, Services  | Vuex, Pinia    |
| Learning Curve   | Moderate        | Steep           | Easy           |
| Virtual DOM      | ✅ Yes           | ❌ No            | ✅ Yes          |

📌 **Key Differences:**  
- **React** is a UI library, whereas **Angular/Vue** are full frameworks.  
- **Angular** uses **TypeScript** and has **two-way data binding**, while React/Vue follow a **one-way data flow**.  
- **Vue** offers a balance between React’s flexibility and Angular’s structure.  

---

## **🔹 Class Components vs. Functional Components**  
1️⃣ **Class Components (Before React 16.8)**  
- Uses `this.state` and `this.setState()`.  
- Requires lifecycle methods (`componentDidMount`, etc.).  
- More complex and **harder to test**.  

2️⃣ **Functional Components (With Hooks)**  
- Uses `useState` instead of `this.state`.  
- Easier to read and test.  
- **Better performance** due to no class instances.  

✅ **Example: Converting a Class to a Functional Component**  
```tsx
// Class Component
class Counter extends React.Component {
  state = { count: 0 };

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return <button onClick={this.increment}>{this.state.count}</button>;
  }
}

// Functional Component
const Counter = () => {
  const [count, setCount] = React.useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
};
```

📌 **Use Functional Components** for better performance and readability!  

---

## **🔹 How React Reconciliation Works**  
🔹 **Reconciliation** is React’s **diffing algorithm** to update the UI efficiently.  
🔹 Uses the **Virtual DOM** to compare changes.  
🔹 React updates only the necessary parts of the DOM (avoiding unnecessary re-renders).  

✅ **Key Rules:**  
1. **Different elements → Full re-render.**  
2. **Same elements → Updates only changed attributes.**  
3. **Lists need keys to optimize reconciliation.**  

---

## **🔹 Virtual DOM vs. Real DOM**  
| Feature       | Virtual DOM        | Real DOM         |
|--------------|-------------------|------------------|
| Speed        | Fast               | Slow             |
| Re-renders   | Updates only changed elements | Rebuilds entire DOM tree |
| Efficiency   | Memory-efficient    | More resource-intensive |

📌 **React uses Virtual DOM to improve performance.**  

---

## **🔹 PureComponent vs. React.memo**  
- `PureComponent` is for **class components** (prevents unnecessary re-renders).  
- `React.memo` is for **functional components** (prevents re-renders if props remain the same).  

✅ **Example:**  
```tsx
const MemoizedComponent = React.memo(({ name }) => {
  console.log("Rendering...");
  return <h1>Hello, {name}</h1>;
});
```
📌 **Use `React.memo` to optimize functional components!**  

---

## **🔹 React Fiber Architecture**  
🔹 **Fiber** is the re-implementation of React’s **reconciliation algorithm**.  
🔹 Enables **concurrent rendering**, improving app responsiveness.  
🔹 Prioritizes rendering tasks for **smooth UI updates**.  

📌 **React Fiber is why React 18 introduced features like `useTransition`.**  

---

## **🔹 Why Use `useCallback` & `useMemo`?**  
- **`useCallback(fn, deps)`**: Prevents function re-creations.  
- **`useMemo(value, deps)`**: Prevents expensive calculations from re-running.  

✅ **Example:**  
```tsx
const memoizedValue = useMemo(() => expensiveCalculation(data), [data]);
const memoizedCallback = useCallback(() => console.log("Clicked"), []);
```
📌 **Use them to improve performance by avoiding unnecessary calculations!**  

---

## **🔹 Event Delegation in React**  
- React **attaches events at the root (`document`)** instead of each element.  
- Uses **event bubbling** to handle all events efficiently.  

✅ **Example:**  
```tsx
const Parent = () => {
  const handleClick = (event) => {
    console.log("Clicked: ", event.target);
  };
  return <div onClick={handleClick}><button>Click Me</button></div>;
};
```
📌 **Improves performance by reducing the number of event listeners!**  

---

## **🔹 Server-Side Rendering (SSR) vs. Client-Side Rendering (CSR)**  
| Feature        | SSR (Next.js)        | CSR (React)         |
|---------------|---------------------|---------------------|
| First Load    | Fast (pre-rendered) | Slow (waits for JS) |
| SEO Friendly  | ✅ Yes               | ❌ No              |
| Performance   | Better for slow networks | Can be slower |
| Best For      | Blogs, SEO pages     | SPAs, dashboards |

📌 **Use Next.js for SSR if SEO is important!**  

---

## **🔹 Hydration in React 18**  
🔹 **Hydration** is the process of attaching event listeners **after SSR loads HTML**.  
🔹 React 18 **improves hydration** with **Concurrent Rendering**.  
🔹 Enables **Streaming SSR**, loading only necessary parts first.  

---

## **🔹 Handling Memory Leaks in React**  
🔹 **Avoid memory leaks** by cleaning up effects:  
✅ **Fix Unmounted Component Issue:**  
```tsx
useEffect(() => {
  const interval = setInterval(() => console.log("Running"), 1000);
  return () => clearInterval(interval); // Cleanup function
}, []);
```
📌 **Always clean up side effects to prevent memory leaks!**  

---

## **🔹 React Strict Mode**  
- Detects **potential problems** in components.  
- Helps identify **unsafe lifecycle methods**.  

✅ **Usage in `index.tsx`**  
```tsx
<React.StrictMode>
  <App />
</React.StrictMode>
```
📌 **Use Strict Mode in development for better debugging!**  

---

## **🔹 React Internals (How React Updates UI?)**  
- React **creates a Virtual DOM tree**.  
- Uses **diffing & reconciliation** to find changes.  
- **Batch updates** improve performance.  

✅ **Example: Batched Updates in React 18**  
```tsx
const handleClick = () => {
  setCount(c => c + 1);
  setCount(c => c + 1);
};
```
📌 **In React 18, both updates happen together (batching), preventing extra re-renders.**  

---

# **📌 Summary**  
✔ **React vs. Angular/Vue** – Know the differences.  
✔ **Functional vs. Class Components** – Prefer functions with hooks.  
✔ **Virtual DOM, Reconciliation, Fiber** – Key optimizations.  
✔ **SSR vs. CSR, Hydration** – Important for performance & SEO.  
✔ **`useCallback`, `useMemo`** – Optimize re-renders.  
✔ **Event Delegation & Strict Mode** – Improve efficiency.  
✔ **Memory Leaks & React Internals** – Important debugging concepts.  

🔥 **Next Steps: Prepare for hands-on coding rounds and system design discussions!** 🚀  

Let me know if you need any improvements! 💡