# **5️⃣ State Management in React**  

State management is essential for handling complex applications where **multiple components need to share and update state** efficiently. React offers built-in state (`useState`, `useReducer`, `useContext`), but for large-scale applications, **external state management libraries** like Redux, Zustand, and Recoil are often preferred.  

---

## **5.1 Why State Management?**  

### **When Do You Need State Management?**  
✅ When multiple components **share data** (e.g., user authentication state).  
✅ When data is **frequently updated** (e.g., shopping cart, live notifications).  
✅ When **prop drilling** (passing props through multiple levels) becomes cumbersome.  
✅ When caching, optimistic updates, or server-state synchronization are required.  

📌 **Alternatives:** Before using Redux or Zustand, check if **Context API + useReducer** is sufficient.  

---

## **5.2 Redux Core Concepts**  

### **What is Redux?**  
Redux is a predictable state container that helps manage global state across an application.  

### **Key Concepts**  
| Concept | Description |
|---------|------------|
| **Store** | Holds the entire application state. |
| **Actions** | Objects describing what should change (e.g., `{ type: "ADD_ITEM", payload: item }`). |
| **Reducers** | Functions that specify how state changes based on an action. |
| **Dispatch** | Sends actions to the store. |
| **Selectors** | Extract state values efficiently. |

### **Basic Redux Example**  

🔹 **1️⃣ Define Actions**  
```tsx
const ADD_TODO = "ADD_TODO";

interface AddTodoAction {
  type: typeof ADD_TODO;
  payload: string;
}

export const addTodo = (todo: string): AddTodoAction => ({
  type: ADD_TODO,
  payload: todo,
});
```

🔹 **2️⃣ Create Reducer**  
```tsx
interface TodoState {
  todos: string[];
}

const initialState: TodoState = { todos: [] };

const todoReducer = (state = initialState, action: AddTodoAction): TodoState => {
  switch (action.type) {
    case ADD_TODO:
      return { todos: [...state.todos, action.payload] };
    default:
      return state;
  }
};
```

🔹 **3️⃣ Create Store**  
```tsx
import { createStore } from "redux";
const store = createStore(todoReducer);
```

📌 **Problem with Redux:** Too much boilerplate! That’s where **Redux Toolkit (RTK)** helps.  

---

## **5.3 Redux Toolkit (RTK)**  

Redux Toolkit (RTK) simplifies Redux by reducing boilerplate and improving state management efficiency.  

### **Why Use Redux Toolkit?**  
✅ Auto-generates action creators and reducers.  
✅ Simplifies store configuration with `configureStore()`.  
✅ Built-in support for **async actions** via `createAsyncThunk()`.  

### **Setting Up Redux Toolkit**  

🔹 **1️⃣ Install Redux Toolkit & React-Redux**  
```sh
npm install @reduxjs/toolkit react-redux
```

🔹 **2️⃣ Create a Slice (Reducers + Actions)**  
```tsx
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

interface CounterState {
  value: number;
}

const initialState: CounterState = { value: 0 };

const counterSlice = createSlice({
  name: "counter",
  initialState,
  reducers: {
    increment: (state) => { state.value += 1; },
    decrement: (state) => { state.value -= 1; },
    addByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    },
  },
});

export const { increment, decrement, addByAmount } = counterSlice.actions;
export default counterSlice.reducer;
```

🔹 **3️⃣ Configure the Store**  
```tsx
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./counterSlice";

export const store = configureStore({
  reducer: { counter: counterReducer },
});
```

🔹 **4️⃣ Use Redux in a Component**  
```tsx
import { useDispatch, useSelector } from "react-redux";
import { increment, decrement } from "./counterSlice";

const Counter: React.FC = () => {
  const count = useSelector((state: { counter: { value: number } }) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
};
```

📌 **RTK simplifies Redux and is the recommended way to use it in React.**  

---

## **5.4 React Query for Data Fetching**  

### **Why Use React Query?**  
✅ Handles **caching, refetching, pagination, mutations, and background updates**.  
✅ Reduces the need for **global state** (you don’t need Redux just for API calls).  

### **Example: Fetching Data with React Query**  

🔹 **1️⃣ Install React Query**  
```sh
npm install @tanstack/react-query
```

🔹 **2️⃣ Setup Query Client Provider**  
```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <MyComponent />
    </QueryClientProvider>
  );
}
```

🔹 **3️⃣ Fetch Data with `useQuery`**  
```tsx
import { useQuery } from "@tanstack/react-query";

const fetchTodos = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/todos");
  return response.json();
};

const TodoList = () => {
  const { data, isLoading, error } = useQuery({ queryKey: ["todos"], queryFn: fetchTodos });

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Error fetching data</p>;

  return <ul>{data.map((todo) => <li key={todo.id}>{todo.title}</li>)}</ul>;
};
```

📌 **React Query is the best choice for managing server state!**  

---

## **5.5 Zustand (Lightweight State Management)**  

### **Why Use Zustand?**  
✅ Simpler than Redux, no boilerplate.  
✅ Uses **React hooks**, making it lightweight and efficient.  

### **Example: Zustand Store**  

🔹 **1️⃣ Install Zustand**  
```sh
npm install zustand
```

🔹 **2️⃣ Create a Store**  
```tsx
import { create } from "zustand";

interface CounterState {
  count: number;
  increment: () => void;
}

const useCounterStore = create<CounterState>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));

export default useCounterStore;
```

🔹 **3️⃣ Use Zustand in a Component**  
```tsx
const Counter = () => {
  const { count, increment } = useCounterStore();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
    </div>
  );
};
```

📌 **Zustand is a great alternative to Redux for smaller apps.**  

---

## **5.6 Recoil & Jotai**  

### **Recoil**  
✅ **Fine-grained reactivity** (unlike Redux, which updates the whole store).  
✅ **Ideal for sharing state across deeply nested components**.  

🔹 **Install Recoil**  
```sh
npm install recoil
```

🔹 **Example: Recoil Atom (Shared State)**  
```tsx
import { atom, useRecoilState } from "recoil";

const counterState = atom({ key: "counter", default: 0 });

const Counter = () => {
  const [count, setCount] = useRecoilState(counterState);
  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
};
```

📌 **Jotai is similar to Recoil but has a simpler API.**  

---

🔥 **Next Topic: 6️⃣ React Interview Questions & Best Practices**  

Let me know if you need changes or more details! 🚀