# **3Ô∏è‚É£ React Advanced Topics**  

## **3.1 React Portals**  

### **What are React Portals?**  
- Portals allow rendering a **component outside the parent DOM hierarchy** while preserving React's event handling.  
- Useful for **modals, tooltips, pop-ups**, and elements that need to break out of parent styles (like `overflow: hidden`).  

### **How to Create a Portal?**  

üîπ **Step 1: Create a `div` in `index.html`**  
```html
<div id="modal-root"></div>
```

üîπ **Step 2: Render Component using `ReactDOM.createPortal()`**  
```jsx
import React from "react";
import ReactDOM from "react-dom";

function Modal({ children }) {
  return ReactDOM.createPortal(
    <div className="modal">{children}</div>,
    document.getElementById("modal-root")
  );
}

export default Modal;
```

üîπ **Step 3: Use the Portal in Your Component**  
```jsx
function App() {
  return (
    <div>
      <h1>React Portals Example</h1>
      <Modal>
        <p>This is inside a portal!</p>
      </Modal>
    </div>
  );
}
```

üìå **Portals do not interfere with event bubbling, making them ideal for modals and overlays.**  

---

## **3.2 Error Boundaries**  

### **What are Error Boundaries?**  
- Components that **catch JavaScript errors** in their child components and **prevent entire app crashes**.  
- Implemented using class components with `componentDidCatch` and `getDerivedStateFromError`.  

### **Example: Creating an Error Boundary**
```jsx
import React, { Component } from "react";

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("Error caught:", error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Something went wrong!</h2>;
    }
    return this.props.children;
  }
}

export default ErrorBoundary;
```

üîπ **Usage:** Wrap components inside `<ErrorBoundary>`  
```jsx
<ErrorBoundary>
  <ComponentThatMayFail />
</ErrorBoundary>
```

üìå **Hooks Alternative:** No built-in way yet, but React 18+ has `useErrorBoundary` in experimental libraries.  

---

## **3.3 Higher-Order Components (HOC)**  

### **What is an HOC?**  
- A function that **takes a component and returns a new component** with extra functionality.  
- Used for **code reuse**, **authentication wrappers**, **logging**, etc.  

### **Example: Creating an HOC**  
```jsx
function withLogger(WrappedComponent) {
  return function LoggedComponent(props) {
    console.log("Rendering:", WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
}
```

üîπ **Usage:**  
```jsx
function MyComponent() {
  return <h2>Hello from MyComponent</h2>;
}

const EnhancedComponent = withLogger(MyComponent);
```

üìå **Alternatives:** Use **custom hooks** instead of HOCs for better readability.  

---

## **3.4 Render Props**  

### **What is Render Props?**  
- A technique where a component **receives a function as a prop** to control what it renders.  
- Used for **sharing logic** without HOCs.  

### **Example: Render Prop Pattern**  
```jsx
class MouseTracker extends React.Component {
  constructor(props) {
    super(props);
    this.state = { x: 0, y: 0 };
  }

  handleMouseMove = event => {
    this.setState({ x: event.clientX, y: event.clientY });
  };

  render() {
    return (
      <div onMouseMove={this.handleMouseMove} style={{ height: "100vh" }}>
        {this.props.render(this.state)}
      </div>
    );
  }
}
```

üîπ **Usage:**  
```jsx
<MouseTracker render={({ x, y }) => <h2>Mouse at {x}, {y}</h2>} />
```

üìå **Alternatives:** React Hooks (`useState`, `useEffect`) make render props less necessary.  

---

## **3.5 React Suspense & Lazy Loading**  

### **What is Suspense?**  
- Suspense allows delaying UI rendering until **data or components are ready**.  
- Used with **lazy-loaded components**.  

### **Lazy Loading with `React.lazy`**  
```jsx
import React, { Suspense, lazy } from "react";

const LazyComponent = lazy(() => import("./MyComponent"));

function App() {
  return (
    <Suspense fallback={<h2>Loading...</h2>}>
      <LazyComponent />
    </Suspense>
  );
}
```

üìå **Only works with default exports.**  

---

## **3.6 Code Splitting**  

### **Why Code Splitting?**  
- Reduces **initial bundle size**.  
- Loads only the required code when needed.  

### **Example: Dynamic Import**  
```jsx
const loadComponent = () => import("./Component");
```

üìå **Use tools like Webpack, Vite, or Next.js for advanced code splitting.**  

---

## **3.7 Performance Optimization in React**  

### **1Ô∏è‚É£ Memoization (`React.memo`)**  
- Prevents re-rendering if props **haven‚Äôt changed**.  
```jsx
const MemoizedComponent = React.memo(MyComponent);
```

### **2Ô∏è‚É£ Avoid Unnecessary Re-renders**  
- Use `useMemo` and `useCallback` for expensive calculations and functions.  
```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

### **3Ô∏è‚É£ Virtualization with `react-window`**  
- Optimizes long lists by rendering only visible items.  
```sh
npm install react-window
```
```jsx
import { FixedSizeList } from "react-window";

function List({ items }) {
  return (
    <FixedSizeList height={400} width={300} itemSize={50} itemCount={items.length}>
      {({ index, style }) => <div style={style}>{items[index]}</div>}
    </FixedSizeList>
  );
}
```

### **4Ô∏è‚É£ Avoid Inline Functions in JSX**  
‚ùå Bad:  
```jsx
<button onClick={() => handleClick()}>Click</button>
```
‚úÖ Good:  
```jsx
const memoizedClick = useCallback(handleClick, []);
<button onClick={memoizedClick}>Click</button>
```

---

üî• **Next Topic: 4Ô∏è‚É£ React Interview Questions & Best Practices**  

Let me know if you need modifications or explanations! üöÄ