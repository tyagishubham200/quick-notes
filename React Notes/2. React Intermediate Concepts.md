# **2Ô∏è‚É£ React Intermediate Concepts**  

## **2.1 Hooks Overview & Rules**  

### **What are Hooks?**  
- Hooks **allow functional components to use state and lifecycle features** previously available only in class components.  
- Introduced in **React 16.8** to simplify state management and side effects in functional components.  
- **Common Hooks:**  
  - `useState` ‚Üí For state management  
  - `useEffect` ‚Üí For side effects (API calls, subscriptions, etc.)  
  - `useRef` ‚Üí For referencing DOM elements and persisting values without re-rendering  
  - `useMemo` & `useCallback` ‚Üí For performance optimizations  
  - `useContext` ‚Üí For global state management  

### **Rules of Hooks**  
‚úÖ **Only Call Hooks at the Top Level** ‚Üí Do not call hooks inside loops, conditions, or nested functions.  
‚úÖ **Only Call Hooks in React Functions** ‚Üí Hooks must be used inside functional components or custom hooks.  
‚úÖ **Always Use Hooks in the Same Order** ‚Üí Ensures React can track state correctly.  

üîπ **Bad Example (Violates Rules):**  
```jsx
if (someCondition) {
  const [count, setCount] = useState(0); // ‚ùå Incorrect (inside condition)
}
```

üîπ **Correct Example:**  
```jsx
const [count, setCount] = useState(0); // ‚úÖ Correct (top-level function)
```

---

## **2.2 useState Hook**  

### **What is `useState`?**  
- Allows functional components to manage **local state**.  
- Returns **two values**:  
  1. **Current state value**  
  2. **Function to update state**  

### **Syntax:**  
```jsx
const [state, setState] = useState(initialValue);
```

### **Example: Counter with `useState`**
```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### **Updating State Correctly**  
üöÄ **If state depends on previous value, use function inside `setState`**:  
```jsx
setCount(prevCount => prevCount + 1); 
```

---

## **2.3 useEffect Hook**  

### **What is `useEffect`?**  
- Allows functional components to **handle side effects** like:  
  ‚úÖ Fetching API data  
  ‚úÖ Setting up event listeners  
  ‚úÖ Updating the DOM manually  
- **Replaces** lifecycle methods like `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`  

### **Syntax:**  
```jsx
useEffect(() => {
  // Side effect code here
}, [dependencies]);
```

### **Example: Fetching Data with `useEffect`**
```jsx
import { useEffect, useState } from "react";

function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("https://api.example.com/data")
      .then(res => res.json())
      .then(data => setData(data));
  }, []); // Empty dependency array runs effect only on mount

  return <div>{data ? JSON.stringify(data) : "Loading..."}</div>;
}
```

### **Dependency Array Behavior:**  
‚úÖ `[]` ‚Üí Runs once on mount  
‚úÖ `[state]` ‚Üí Runs when `state` changes  
‚úÖ No dependencies ‚Üí Runs on **every** re-render  

üöÄ **Cleanup Function (`componentWillUnmount` equivalent)**  
```jsx
useEffect(() => {
  const interval = setInterval(() => {
    console.log("Interval running");
  }, 1000);

  return () => clearInterval(interval); // Cleanup function
}, []);
```

---

## **2.4 useRef Hook**  

### **What is `useRef`?**  
- Used to **persist values** between renders **without causing re-renders**.  
- Can reference **DOM elements** directly.  

### **Example: Accessing DOM Elements**
```jsx
import { useRef, useEffect } from "react";

function InputFocus() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus();
  }, []);

  return <input ref={inputRef} placeholder="Auto Focused" />;
}
```

### **Example: Persisting Values Across Renders**  
```jsx
import { useRef, useState } from "react";

function RenderCounter() {
  const renderCount = useRef(0);
  const [name, setName] = useState("");

  useEffect(() => {
    renderCount.current += 1;
  });

  return (
    <div>
      <input value={name} onChange={e => setName(e.target.value)} />
      <p>Component rendered {renderCount.current} times</p>
    </div>
  );
}
```

üìå **Unlike `useState`, changing `useRef` does not trigger re-renders.**  

---

## **2.5 useMemo & useCallback**  

### **Why useMemo & useCallback?**  
- **Performance optimizations**  
- Prevents unnecessary re-calculations (`useMemo`)  
- Prevents function re-creations (`useCallback`)  

### **Example: useMemo (Caches Expensive Computations)**
```jsx
import { useMemo, useState } from "react";

function ExpensiveCalculation({ number }) {
  const squaredNumber = useMemo(() => {
    console.log("Computing...");
    return number * number;
  }, [number]);

  return <p>Square: {squaredNumber}</p>;
}
```

### **Example: useCallback (Memoizing Functions)**
```jsx
import { useCallback, useState } from "react";

function Button({ onClick }) {
  return <button onClick={onClick}>Click Me</button>;
}

function ParentComponent() {
  const [count, setCount] = useState(0);

  const memoizedCallback = useCallback(() => {
    console.log("Button Clicked!");
  }, []);

  return (
    <div>
      <Button onClick={memoizedCallback} />
      <p>Count: {count}</p>
    </div>
  );
}
```

üìå **useMemo ‚Üí Caches values | useCallback ‚Üí Caches functions**  

---

## **2.6 Custom Hooks**  

### **What are Custom Hooks?**  
- Custom Hooks **reuse logic** across multiple components.  
- **Convention:** Custom hooks must start with `use`.  

### **Example: useLocalStorage Hook**
```jsx
import { useState } from "react";

function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    const savedValue = localStorage.getItem(key);
    return savedValue ? JSON.parse(savedValue) : initialValue;
  });

  const setValue = value => {
    setStoredValue(value);
    localStorage.setItem(key, JSON.stringify(value));
  };

  return [storedValue, setValue];
}

// Usage
const [theme, setTheme] = useLocalStorage("theme", "light");
```

üìå **Custom Hooks improve reusability and readability.**  

---

## **2.7 Context API for State Management**  

### **Why use Context API?**  
- Avoids **prop drilling** (passing props deeply).  
- Provides **global state management**.  

### **Steps to Use Context API:**  

1Ô∏è‚É£ **Create Context:**  
```jsx
import { createContext } from "react";

const ThemeContext = createContext("light");
```

2Ô∏è‚É£ **Provide Context:**  
```jsx
<ThemeContext.Provider value="dark">
  <App />
</ThemeContext.Provider>
```

3Ô∏è‚É£ **Consume Context:**  
```jsx
import { useContext } from "react";

const theme = useContext(ThemeContext);
console.log(theme); // Output: dark
```

üìå **Alternative:** Use Redux, Zustand, or Recoil for larger apps.  

---

üî• **Next Topic: 3Ô∏è‚É£ React Advanced Topics**  
Let me know if you want modifications or explanations! üöÄ